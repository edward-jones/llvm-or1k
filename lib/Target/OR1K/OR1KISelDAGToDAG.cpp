//===-- OR1KISelDAGToDAG.cpp - A dag to dag inst selector for OR1K --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the OR1K target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "or1k-isel"
#include "OR1K.h"
#include "OR1KMachineFunctionInfo.h"
#include "OR1KRegisterInfo.h"
#include "OR1KSubtarget.h"
#include "OR1KTargetMachine.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Type.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

namespace {

class OR1KDAGToDAGISel : public SelectionDAGISel {
public:
  explicit OR1KDAGToDAGISel(OR1KTargetMachine &tm)
   : SelectionDAGISel(tm), TM(tm),
     Subtarget(TM.getSubtarget<OR1KSubtarget>()) {}

  const char *getPassName() const override {
    return "OR1K DAG->DAG Pattern Instruction Selection";
  }

  bool SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
                                    std::vector<SDValue> &OutOps) override;

private:
  // Include the pieces autogenerated from the target description.
  #include "OR1KGenDAGISel.inc"

  SDNode *Select(SDNode *N);

  SDNode *SelectFrameIndex(SDNode *Node);
  SDNode *SelectGLOBAL_OFFSET_TABLE(SDNode *Node);
  SDNode *SelectMulHiLo(SDNode *Node);
  SDNode *SelectMulHi(SDNode *Node);
  SDNode *SelectINTRINSIC_CHAIN(SDNode *Node);

  SDNode *SelectMFSPR(SDNode *Node);
  SDNode *SelectMTSPR(SDNode *Node);

  SDValue getGlobalBase();

  bool SelectAddr(SDValue Addr, SDValue &Base, SDValue &Offset);

private:
  OR1KTargetMachine &TM;
  const OR1KSubtarget &Subtarget;
};
}

SDNode* OR1KDAGToDAGISel::Select(SDNode *Node) {
  unsigned Opcode = Node->getOpcode();

  // Dump information about the Node being selected
  DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    return NULL;
  }

  // Instruction Selection not handled by the auto-generated
  // tablegen selection should be handled here.
  switch(Opcode) {
  default: break;
  case ISD::FrameIndex: return SelectFrameIndex(Node);
  case ISD::GLOBAL_OFFSET_TABLE: return SelectGLOBAL_OFFSET_TABLE(Node);
  case ISD::MULHU:
  case ISD::MULHS: return SelectMulHi(Node);
  case ISD::UMUL_LOHI:
  case ISD::SMUL_LOHI: return SelectMulHiLo(Node);
  case ISD::INTRINSIC_VOID:
  case ISD::INTRINSIC_W_CHAIN:
    if (SDNode *ResNode = SelectINTRINSIC_CHAIN(Node))
      return ResNode;
    break;
  }

  // Select the default instruction
  SDNode *ResNode = SelectCode(Node);

  DEBUG(errs() << "=> ");
  if (ResNode == NULL || ResNode == Node)
    DEBUG(Node->dump(CurDAG));
  else
    DEBUG(ResNode->dump(CurDAG));
  DEBUG(errs() << "\n");

  return ResNode;
}

SDValue OR1KDAGToDAGISel::getGlobalBase() {
  MachineFunction &MF = CurDAG->getMachineFunction();
  unsigned GlobalBaseReg = TM.getInstrInfo()->getGlobalBaseReg(MF);
  return CurDAG->getRegister(GlobalBaseReg, MVT::i32);
}

bool OR1KDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base,
                                  SDValue &Offset) {
  // if Address is FI, get the TargetFrameIndex.
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }

  // on PIC code Load GA
  if (TM.getRelocationModel() == Reloc::PIC_) {
    if ((Addr.getOpcode() == ISD::TargetGlobalAddress) ||
        (Addr.getOpcode() == ISD::TargetConstantPool) ||
        (Addr.getOpcode() == ISD::TargetJumpTable)) {
      Base = getGlobalBase();
      Offset = Addr;
      return true;
    }
  } else {
    if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
        Addr.getOpcode() == ISD::TargetGlobalAddress))
      return false;
  }

  // Addresses of the form FI+const or FI|const
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
    if (isInt<16>(CN->getSExtValue())) {

      // If the first operand is a FI, get the TargetFI Node
      if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>
                                  (Addr.getOperand(0)))
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
      else
        Base = Addr.getOperand(0);

      Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
      return true;
    }
  }

  // Operand is a result from an ADD.
  if (Addr.getOpcode() == ISD::ADD) {
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isUInt<16>(CN->getZExtValue())) {

        // If the first operand is a FI, get the TargetFI Node
        if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>
                                    (Addr.getOperand(0))) {
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        } else {
          Base = Addr.getOperand(0);
        }

        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
        return true;
      }
    }
  }

  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, MVT::i32);
  return true;
}

bool OR1KDAGToDAGISel::
SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
                             std::vector<SDValue> &OutOps) {
  SDValue Op0, Op1;
  switch (ConstraintCode) {
  default: return true;
  case 'm':   // memory
    if (!SelectAddr(Op, Op0, Op1))
      return true;
    break;
  }

  OutOps.push_back(Op0);
  OutOps.push_back(Op1);
  return false;
}

SDNode *OR1KDAGToDAGISel::SelectFrameIndex(SDNode *Node) {
  SDValue imm = CurDAG->getTargetConstant(0, MVT::i32);
  int FI = dyn_cast<FrameIndexSDNode>(Node)->getIndex();
  EVT VT = Node->getValueType(0);
  SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
  unsigned Opc = OR1K::ADDI;
  if (Node->hasOneUse())
    return CurDAG->SelectNodeTo(Node, Opc, VT, TFI, imm);
  return CurDAG->getMachineNode(Opc, SDLoc(Node), VT, TFI, imm);
}

SDNode *OR1KDAGToDAGISel::SelectGLOBAL_OFFSET_TABLE(SDNode *Node) {
  return getGlobalBase().getNode();
}

SDNode *OR1KDAGToDAGISel::SelectMulHiLo(SDNode *Node) {
  assert(Subtarget.hasMul64());
  SDLoc dl(Node);
  bool Signed = Node->getOpcode() == ISD::SMUL_LOHI;
  unsigned Opcode = Signed ? OR1K::MULD : OR1K::MULDU;
  EVT Out0Ty = Node->getValueType(0);
  EVT Out1Ty = Node->getValueType(1);
  SDValue Op0 = Node->getOperand(0);
  SDValue Op1 = Node->getOperand(1);

  return CurDAG->getMachineNode(Opcode, dl, Out0Ty, Out1Ty, Op0, Op1);
}

SDNode *OR1KDAGToDAGISel::SelectMulHi(SDNode *Node) {
  assert(Subtarget.hasMul64());
  SDLoc dl(Node);
  bool Signed = Node->getOpcode() == ISD::MULHS;
  unsigned Opcode = Signed ? OR1K::MULD : OR1K::MULDU;
  EVT Out0Ty = Node->getValueType(0);
  SDValue Op0 = Node->getOperand(0);
  SDValue Op1 = Node->getOperand(1);

  SDNode *Mul = CurDAG->getMachineNode(Opcode, dl, Out0Ty, Out0Ty, Op0, Op1);
  CurDAG->ReplaceAllUsesOfValueWith(SDValue(Node, 0), SDValue(Mul, 1));

  return Mul;
}

SDNode *OR1KDAGToDAGISel::SelectINTRINSIC_CHAIN(SDNode *Node) {
  assert(Node->getOpcode() == ISD::INTRINSIC_VOID ||
         Node->getOpcode() == ISD::INTRINSIC_W_CHAIN);

  uint64_t IID = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();

  switch (IID) {
  default: return nullptr;
  case Intrinsic::or1k_mfspr: return SelectMFSPR(Node);
  case Intrinsic::or1k_mtspr: return SelectMTSPR(Node);
  }
}

SDNode *OR1KDAGToDAGISel::SelectMFSPR(SDNode *Node) {
  SDLoc dl(Node);
  EVT OutTy = Node->getValueType(0);
  // Register, immediate, Chain
  SDValue Ops[3];

  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Node->getOperand(2))) {
    Ops[0] = CurDAG->getRegister(OR1K::R0, MVT::i32);
    Ops[1] = CurDAG->getTargetConstant(C->getZExtValue(), MVT::i32);
  } else {
    Ops[0] = Node->getOperand(2);
    Ops[1] = CurDAG->getTargetConstant(0, MVT::i32);
  }

  Ops[2] = Node->getOperand(0);

  return CurDAG->getMachineNode(OR1K::MFSPR, dl, OutTy, MVT::Other, Ops);
}

SDNode *OR1KDAGToDAGISel::SelectMTSPR(SDNode *Node) {
  SDLoc dl(Node);
  // Register, SrcReg, Immediate, Chain
  SDValue Ops[4];

  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Node->getOperand(3))) {
    Ops[0] = CurDAG->getRegister(OR1K::R0, MVT::i32);
    Ops[2] = CurDAG->getTargetConstant(C->getZExtValue(), MVT::i32);
  } else {
    Ops[0] = Node->getOperand(3);
    Ops[2] = CurDAG->getTargetConstant(0, MVT::i32);
  }

  Ops[1] = Node->getOperand(2);
  Ops[3] = Node->getOperand(0);

  return CurDAG->getMachineNode(OR1K::MTSPR, dl, MVT::Other, Ops);
}

FunctionPass *llvm::createOR1KISelDag(OR1KTargetMachine &TM) {
  return new OR1KDAGToDAGISel(TM);
}
